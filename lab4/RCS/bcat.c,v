head	1.50;
access;
symbols;
locks;
comment	@ * @;


1.50
date	2012.11.04.06.41.55;	author -;	state -;
branches;
next	1.49;

1.49
date	2012.11.04.06.11.02;	author -;	state -;
branches;
next	1.48;

1.48
date	2012.11.04.06.08.56;	author -;	state -;
branches;
next	1.47;

1.47
date	2012.11.04.06.06.14;	author -;	state -;
branches;
next	1.46;

1.46
date	2012.11.04.06.04.40;	author -;	state -;
branches;
next	1.45;

1.45
date	2012.11.04.06.04.08;	author -;	state -;
branches;
next	1.44;

1.44
date	2012.11.04.06.00.53;	author -;	state -;
branches;
next	1.43;

1.43
date	2012.11.04.06.00.41;	author -;	state -;
branches;
next	1.42;

1.42
date	2012.11.04.05.58.44;	author -;	state -;
branches;
next	1.41;

1.41
date	2012.11.04.05.58.17;	author -;	state -;
branches;
next	1.40;

1.40
date	2012.11.04.05.54.43;	author -;	state -;
branches;
next	1.39;

1.39
date	2012.11.04.05.50.48;	author -;	state -;
branches;
next	1.38;

1.38
date	2012.11.04.05.49.42;	author -;	state -;
branches;
next	1.37;

1.37
date	2012.11.04.05.48.21;	author -;	state -;
branches;
next	1.36;

1.36
date	2012.11.04.05.48.01;	author -;	state -;
branches;
next	1.35;

1.35
date	2012.11.04.05.44.31;	author -;	state -;
branches;
next	1.34;

1.34
date	2012.11.04.05.43.00;	author -;	state -;
branches;
next	1.33;

1.33
date	2012.11.04.05.34.56;	author -;	state -;
branches;
next	1.32;

1.32
date	2012.11.04.05.33.54;	author -;	state -;
branches;
next	1.31;

1.31
date	2012.11.04.05.33.22;	author -;	state -;
branches;
next	1.30;

1.30
date	2012.11.04.05.31.44;	author -;	state -;
branches;
next	1.29;

1.29
date	2012.11.04.05.14.02;	author -;	state -;
branches;
next	1.28;

1.28
date	2012.11.04.05.09.51;	author -;	state -;
branches;
next	1.27;

1.27
date	2012.11.04.05.08.04;	author -;	state -;
branches;
next	1.26;

1.26
date	2012.11.04.05.06.03;	author -;	state -;
branches;
next	1.25;

1.25
date	2012.11.04.05.04.40;	author -;	state -;
branches;
next	1.24;

1.24
date	2012.11.04.05.04.14;	author -;	state -;
branches;
next	1.23;

1.23
date	2012.11.04.04.57.32;	author -;	state -;
branches;
next	1.22;

1.22
date	2012.11.04.04.57.00;	author -;	state -;
branches;
next	1.21;

1.21
date	2012.11.04.04.56.31;	author -;	state -;
branches;
next	1.20;

1.20
date	2012.11.04.04.54.13;	author -;	state -;
branches;
next	1.19;

1.19
date	2012.11.04.04.52.51;	author -;	state -;
branches;
next	1.18;

1.18
date	2012.11.04.04.52.16;	author -;	state -;
branches;
next	1.17;

1.17
date	2012.11.04.04.52.07;	author -;	state -;
branches;
next	1.16;

1.16
date	2012.11.04.04.51.31;	author -;	state -;
branches;
next	1.15;

1.15
date	2012.11.04.04.47.56;	author -;	state -;
branches;
next	1.14;

1.14
date	2012.11.04.04.47.38;	author -;	state -;
branches;
next	1.13;

1.13
date	2012.11.04.04.45.53;	author -;	state -;
branches;
next	1.12;

1.12
date	2012.11.04.04.45.13;	author -;	state -;
branches;
next	1.11;

1.11
date	2012.11.04.04.44.12;	author -;	state -;
branches;
next	1.10;

1.10
date	2012.11.04.04.43.35;	author -;	state -;
branches;
next	1.9;

1.9
date	2012.11.04.04.42.34;	author -;	state -;
branches;
next	1.8;

1.8
date	2012.11.04.04.42.04;	author -;	state -;
branches;
next	1.7;

1.7
date	2012.10.24.00.42.37;	author -;	state -;
branches;
next	1.6;

1.6
date	2012.10.23.19.13.36;	author -;	state -;
branches;
next	1.5;

1.5
date	2012.10.23.19.11.53;	author -;	state -;
branches;
next	1.4;

1.4
date	2012.10.23.19.10.22;	author -;	state -;
branches;
next	1.3;

1.3
date	2012.10.23.19.09.51;	author -;	state -;
branches;
next	1.2;

1.2
date	2012.02.01.21.40.11;	author -;	state -;
branches;
next	1.1;

1.1
date	2012.02.01.02.03.46;	author -;	state -;
branches;
next	;


desc
@@


1.50
log
@-
@
text
@// $Id: bcat.c,v 1.49 2012-11-03 23:11:02-07 - - $
// Jacky Wong - jagwong@@ucsc.edu
// ID: 1281439


//
// NAME
//    bcat - concatenate and display files
//
// SYNOPSIS
//    bcat [filename...]
//
// DESCRIPTION
//    The bcat utility reads each file in sequence and writes it
//    to stdout.  If any filename is given as the single character
//    "-", stdin is read at that point.  If no filenames are given
//    then stdin is read as the only file.
//

#include <errno.h>
#include <libgen.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

char *progname = NULL;          // Name of the program being run.
int exit_status = EXIT_SUCCESS; // Assume successful completion.

struct options {                // Structure to hold options.
   bool moretitles;             // Print titles in more-style
   bool numberlines;            // Output line numbers for each line.
   bool squeeze;                // Squeeze multiple empty lines.
};


//
// cat -
// Copy the contents of an already-opened file to stdout.
//

void catfile (FILE *input, char *filename, struct options *opts) {
   char buffer[4096];
   char prevbuffer[4096];
//   char *prevbuffer_ptr = &prevbuffer;
   int linenumber = 0;
   if (opts->moretitles){
      printf("\n");
      for (int i = 0; i<64; i++){
         printf(":");
      }
      printf("\n%s\n", filename);
      for (int i = 0; i<64; i++){
         printf(":");
      }
      printf("\n\n");
   }
   for (;;) {
      char *bufrc = fgets (buffer, sizeof buffer, input);
      linenumber++;
      if (bufrc == NULL) break;
      if (opts->squeeze){
         if (*prevbuffer == '\n' && *buffer == '\n') continue;
      }
      if (opts->numberlines)
          printf("%6d  ",linenumber);
      printf ("%s", buffer);
      strcpy(prevbuffer,buffer);
   };
}


// scanoptions -
// Scan the options and initialize a struct options.
//

void scan_options (int argc, char **argv, struct options *opts) {
   memset (opts, 0, sizeof (struct options));
   opterr = false;
   for (;;) {
      int opt = getopt (argc, argv, "mns");
      if (opt == EOF) break;
      switch (opt) {
         case 'm':
            opts->moretitles = true;
            break;
         case 'n':
            opts->numberlines = true;
            break;
         case 's':
            opts->squeeze = true;
            break;
         default : 
            fflush (NULL);
            fprintf (stderr, "%s: -%c: invalid option\n",
                     progname, optopt);
            fflush (NULL);
            exit_status = EXIT_FAILURE;
       }
   }
}


//
// main -
// Loop over files, if any, and cat each of them to stdout.
// Print error messages if appropriate.
//

int main (int argc, char **argv) {
   exit_status = EXIT_SUCCESS;
   progname = basename (argv[0]);
   struct options opts;
   scan_options (argc, argv, &opts);
   if (optind == argc) {
      catfile (stdin, "-", &opts);
   }else{
      for (int argi = optind; argi < argc; ++argi) {
         char *filename = argv[argi];
         if (strcmp (filename, "-") == 0) {
            catfile (stdin, "-", &opts);
         }else{
            FILE *input = fopen (filename, "r");
            if (input == NULL) {
               fflush (NULL);
               fprintf (stderr, "%s: %s: %s\n", progname,
                        argv[argi], strerror (errno));
               fflush (NULL);
               exit_status = EXIT_FAILURE;
            }else{
               catfile (input, filename, &opts);
               fclose (input);
            };
         };
      };
   };
   return exit_status;
}

@


1.49
log
@-
@
text
@d1 4
a4 1
// $Id: bcat.c,v 1.48 2012-11-03 23:08:56-07 - - $
@


1.48
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.47 2012-11-03 23:06:14-07 - - $
d44 1
a44 1
   int linenumber = -1;
d58 1
a61 1
         linenumber++;
d64 1
a64 1
          printf("%6d  ",++linenumber);
@


1.47
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.46 2012-11-03 23:04:40-07 - - $
d44 1
a44 1
   int linenumber = 0;
@


1.46
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.45 2012-11-03 23:04:08-07 - - $
a58 2
//      if (opts->numberlines)
//         printf ("%6d  ",linenumber++);
d60 1
a61 1
         if (*prevbuffer == '\n' && *buffer == '\n') continue;
@


1.45
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.44 2012-11-03 23:00:53-07 - - $
d62 1
a62 1
         linenumber = linenumber++;
@


1.44
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.43 2012-11-03 23:00:41-07 - - $
d44 1
a44 1
   int linenumber = 1;
d59 2
a60 2
      if (opts->numberlines)
         printf ("%6d  ",linenumber++);
d62 1
d65 2
@


1.43
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.42 2012-11-03 22:58:44-07 - - $
d62 1
a62 1
         if (*prevbuffer == '\n' && buffer == '\n') continue;
@


1.42
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.41 2012-11-03 22:58:17-07 - - $
d62 1
a62 1
         if (*prevbuffer == '\n') continue;
@


1.41
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.40 2012-11-03 22:54:43-07 - - $
d65 1
a65 1
      strcpy( buffer, prevbuffer);
@


1.40
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.39 2012-11-03 22:50:48-07 - - $
d65 1
a65 1
      *prevbuffer =  buffer;
@


1.39
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.38 2012-11-03 22:49:42-07 - - $
d65 1
a65 1
      prevbuffer =  buffer;
@


1.38
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.37 2012-11-03 22:48:21-07 - - $
d65 1
a65 1
      &prevbuffer =  buffer;
@


1.37
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.36 2012-11-03 22:48:01-07 - - $
d65 1
a65 1
      &prevbuffer =  &buffer;
@


1.36
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.35 2012-11-03 22:44:31-07 - - $
d65 1
a65 1
      prevbuffer =  &buffer;
@


1.35
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.34 2012-11-03 22:43:00-07 - - $
d43 1
d65 1
a65 1
      prevbuffer* =  buffer;
@


1.34
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.33 2012-11-03 22:34:56-07 - - $
d64 1
a64 1
      prevbuffer =  &buffer;
@


1.33
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.32 2012-11-03 22:33:54-07 - - $
d49 1
a49 3
      printf("\n");
      printf("%s", filename);
      printf("\n");
d64 1
a64 1
      prevbuffer =  buffer;
@


1.32
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.31 2012-11-03 22:33:22-07 - - $
d63 1
a63 2
         if (*prevbuffer == '\n');
         continue;
@


1.31
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.30 2012-11-03 22:31:44-07 - - $
d63 1
a63 1
         if (prevbuffer == '\n');
@


1.30
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.29 2012-11-03 22:14:02-07 - - $
d63 1
a63 1
         if (prevbuffer == "\n");
@


1.29
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.28 2012-11-03 22:09:51-07 - - $
d42 1
d62 4
d67 1
@


1.28
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.27 2012-11-03 22:08:04-07 - - $
d42 1
a44 3
      for (int i = 0; i<5; i++){
      printf(":");
      }
a54 1
     
d59 2
@


1.27
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.26 2012-11-03 22:06:03-07 - - $
d44 4
a47 1
      for (int i = 0; i<63; i++){
d53 1
a53 1
      for (int i = 0; i<63; i++){
@


1.26
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.25 2012-11-03 22:04:40-07 - - $
d47 1
d49 1
@


1.25
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.24 2012-11-03 22:04:14-07 - - $
d45 1
a45 1
      printf(":");
d49 2
a50 1
      printf(":");
@


1.24
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.23 2012-11-03 21:57:32-07 - - $
d48 1
a48 1
      for (int i = 0l i<63; i++){
@


1.23
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.22 2012-11-03 21:57:00-07 - - $
d43 4
a46 2
      printf("\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
d48 3
a50 1
      printf("\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
@


1.22
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.21 2012-11-03 21:56:31-07 - - $
d43 2
a44 1
      printf("\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
@


1.21
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.20 2012-11-03 21:54:13-07 - - $
d43 1
a43 2
      printf("\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
d45 1
a45 2
      printf("\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                         ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
@


1.20
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.19 2012-11-03 21:52:51-07 - - $
d42 1
a42 1
   if (moretitles==true){
@


1.19
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.18 2012-11-03 21:52:16-07 - - $
d29 3
a31 3
   bool moretitles = false;             // Print titles in more-style
   bool numberlines = false;            // Output line numbers for each line.
   bool squeeze = false;                // Squeeze multiple empty lines.
d42 1
a42 1
   if (moretitles){
@


1.18
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.17 2012-11-03 21:52:07-07 - - $
d29 3
a31 3
   bool moretitles;             // Print titles in more-style
   bool numberlines;            // Output line numbers for each line.
   bool squeeze;                // Squeeze multiple empty lines.
@


1.17
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.16 2012-11-03 21:51:31-07 - - $
d42 1
a42 1
   if (*moretitles){
@


1.16
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.15 2012-11-03 21:47:56-07 - - $
d42 1
a42 1
   if (&moretitles){
@


1.15
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.14 2012-11-03 21:47:38-07 - - $
d42 1
a42 1
/*   if (moretitles){
d48 1
a48 1
  */   
@


1.14
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.13 2012-11-03 21:45:53-07 - - $
d42 1
a42 1
   if (moretitles){
d48 1
a48 1
     
@


1.13
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.12 2012-11-03 21:45:13-07 - - $
d42 1
a42 1
   if (*opts.moretitles){
@


1.12
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.11 2012-11-03 21:44:12-07 - - $
d42 1
a42 1
   if (*moretitles){
@


1.11
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.10 2012-11-03 21:43:35-07 - - $
d42 1
a42 1
   if (&opt.moretitles){
@


1.10
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.9 2012-11-03 21:42:34-07 - - $
d42 1
a42 1
   if (opt.moretitles){
@


1.9
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.8 2012-11-03 21:42:04-07 - - $
d42 1
a42 1
   if (moretitles){
@


1.8
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.7 2012-10-23 17:42:37-07 - - $
d43 1
a43 1
      out.printf("\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
d45 2
a46 2
      out.printf("%s", filename);
      out.printf("\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@


1.7
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.6 2012-10-23 12:13:36-07 - - $
d42 8
@


1.6
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.5 2012-10-23 12:11:53-07 - - $
d92 1
a92 1
   if (argc == 1) {
@


1.5
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.4 2012-10-23 12:10:22-07 - - $
d41 1
d43 3
a45 3
      int byte = getc (input);
      if (byte == EOF) break;
      (void) putchar (byte);
@


1.4
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.3 2012-10-23 12:09:51-07 - - $
d40 1
a40 1
void catfile (FILE *input) {
d92 1
a92 1
      catfile (stdin);
d97 1
a97 1
            catfile (stdin);
d107 1
a107 1
               catfile (input);
@


1.3
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.2 2012-02-01 13:40:11-08 - - $
a18 1
#include <stdarg.h>
d23 1
@


1.2
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.1 2012-01-31 18:03:46-08 - - $
d11 1
a11 1
//    The `bcat' utility reads each file in sequence and writes it
d13 1
a13 1
//    `-', stdin is read at that point.  If no filenames are given
d20 1
d25 10
d49 31
d87 4
a90 2
   int exit_status = EXIT_SUCCESS;
   char *progname = basename (argv[0]);
d94 3
a96 2
      for (int argi = 1; argi < argc; ++argi) {
         if (strcmp (argv[argi], "-") == 0) {
d99 1
a99 1
            FILE *input = fopen (argv[argi], "r");
@


1.1
log
@-
@
text
@d1 1
a1 1
// $Id: bcat.c,v 1.1 2011-01-25 19:30:06-08 - - $
a70 50

/*
*****************************************************************

Whenever a man page is referenced, read it online.  For example,
when we refer to `stdio(3c)', you can read it with ``man -s 3C
stdio''.

As described in stdio(3c), there are three FILE* handles that
are always opened when a program starts:  `stdin', `stdout', and
`stderr'.  These are, respectively, the standard input, standard
output, and standard error.  Normal output is written to stdout,
while error messages are written to stderr.

The usual format of an error message is something like:
.   progname: object_or_function: reason
The reason a system call has failed is given in the external
variable `errno'.  This can be translated into English via
strerror(3c).

`fopen(3c)' opens a file and returns a pointer to a `FILE',
given a filename.  `fclose(3c)' closes that file, given a
FILE*.  `putchar(3c)' writes one byte to stdout.  `getc(3c)'
reads one byte from the FILE* given as an argument and returns
an int containing the character, if one exists.  If not, returns
EOF (-1).  Note that end of line is signalled by '\n'.  To
signal EOF from a Unix terminal, type Control/D as the first
character on a line.

Strings are represented as arrays of characters.  Each string
ends with a null plug ('\0').  `strcmp(3c)' compares two such
character strings and returns a number that is <, =, or > 0,
depending on the relationship.  See Java's compareTo function.

Some functions return values instead of void, but we often don't
care what these values are, so we use the function in a
statement context.  This causes lint(1) to complain:  ``function
returns value which is always ignored''.  So we explicitly cast
the results of these functions to (void) in order to suppress
this error.  Alternately we could have use a drop-in macro to
replace them.

The call fflush (NULL) causes all opened FILE* handles to be
flushed.  When a program writes data, it is buffered in memory
before being written to the disk.  This causes immediate writing
instead of waiting until the buffer is full.  We do this so that
anything written to stdout and stderr are properly interleaved.

*****************************************************************
*/
@
